-- Sourcefs is copied to destFs, but follows filter rules and ignores deps folder.
-- Missing dependencies are then installed to destFs, but sourceFs deps are used if present.

-- 1 Import to db applying filter rules.
-- 2 Get extra dependencies sources from source fs
-- 3 Install dependencies to db tree getting new hash (using extra source).
-- 4 Export new hash to zip file or fs, with nativeOnly filter.

local import = require('import')
local getInstalled = require('get-installed')


-- Source can be fs or zip file
return function (db, source, rules)
  local kind, hash = import(db, source, "", rules, true)
  local deps = getInstalled(source, "")
  p(kind, hash, deps)
  -- p(filterTree(db, "", ))
  -- p(rules)
end
--
-- local function importBlob(writer, path, hash)
--   local data = db.loadAs("blob", hash)
--   local base = path:match("^(.*)%.lua$")
--   if base then
--     -- TODO: add an option to disable this in case you want uncompiled lua files.
--     log("compiling", path)
--     data = string.dump(loadstring(data, "bundle:" .. path))
--   end
--   writer:add(path, data, 9)
-- end
--
-- local function importTree(writer, path, hash)
--   local tree = db.loadAs("tree", hash)
--   if path then
--     writer:add(path .. "/", "")
--   end
--   for i = 1, #tree do
--     local entry = tree[i]
--     local newPath = path and path .. '/' .. entry.name or entry.name
--     if entry.mode == modes.tree then
--       importTree(writer, newPath, entry.hash)
--     else
--       importBlob(writer, newPath, entry.hash)
--     end
--   end
-- end
--
-- local function importPath(writer, fs, root, path, rules)
--   local kind, hash = import(db, fs, pathJoin(root, path), rules, true)
--   if kind == "tree" then
--     importTree(writer, path, hash)
--   else
--     importBlob(writer, path, hash)
--   end
-- end
--
-- local function importDb(writer, path, hash, rules)
--   hash = filterTree(db, path, hash, rules, true)
--   return importTree(writer, path, hash)
-- end
--
--
--
-- local function realMake(fs, path, meta, target)
--   if not target then
--     target = meta.target or meta.name:match("[^/]+$")
--     if require('ffi').os == "Windows" then
--       target = target .. ".exe"
--     end
--   end
--   log("creating binary", target, "highlight")
--
--   local tempFile = target:gsub("[^/\\]+$", ".%1.temp")
--   local fd = assert(uv.fs_open(tempFile, "w", 511)) -- 0777
--
--   local binSize
--   if meta.luvi and not (meta.luvi.flavor == "regular" and semver.gte(luvi.version, meta.luvi.version)) then
--     local url = luviUrl(meta.luvi)
--     log("downloading custom luvi", url)
--     -- TODO: stream the binary and show progress
--     local res, bin = http.request("GET", url, {})
--     assert(res.code == 200, bin)
--     binSize = #bin
--     uv.fs_write(fd, bin, -1)
--   else      -- Copy base binary
--     do
--       local source = uv.exepath()
--
--       local reader = miniz.new_reader(source)
--       if reader then
--         -- If contains a zip, find where the zip starts
--         binSize = reader:get_offset()
--       else
--         -- Otherwise just read the file size
--         binSize = uv.fs_stat(source).size
--       end
--       local fd2 = assert(uv.fs_open(source, "r", 384)) -- 0600
--       log("copying binary prefix", binSize .. " bytes from " .. source)
--       assert(uv.fs_sendfile(fd, fd2, 0, binSize))
--       uv.fs_close(fd2)
--     end
--   end
--
--   local writer = miniz.new_writer()
--
--   log("importing", #path > 0 and path or fs.base, "highlight")
--   -- TODO: Find target relative to path and use that instead of just target
--   importPath(writer, fs, path, nil, { "!" .. target })
--
--   if meta.dependencies then
--     local deps = {}
--     local modulesDir = pathJoin(path, "deps")
--     writer:add("deps/", "")
--     core.processDeps(deps, fs, modulesDir, meta.dependencies)
--     for alias, dep in pairs(deps) do
--       local tag = dep.author .. '/' .. dep.name .. '@' .. dep.version
--       if dep.disk then
--         local name = "deps/" .. (dep.disk:match("([^/\\]+)$") or alias)
--         log("adding", tag .. ' (' .. dep.disk .. ')', "highlight")
--         importPath(writer, fs, path, name)
--       elseif dep.hash then
--         log("adding", tag, "highlight")
--         local tag = db.loadAs("tag", dep.hash)
--         if tag.type == "tree" then
--           importDb(writer, "deps/" .. alias, tag.object)
--         elseif tag.type == "blob" then
--           importBlob(writer, "deps/" .. alias .. ".lua", tag.object)
--         end
--       end
--     end
--   end
--
--   assert(uv.fs_write(fd, writer:finalize(), binSize))
--   uv.fs_close(fd)
--   assert(uv.fs_rename(tempFile, target))
--   log("done building", target)
-- end
--
--   function core.make(path, target)
--     local fs, newPath = vfs(path)
--     local meta = pkg.query(fs, newPath)
--     if not meta then
--       error("Not a package at: " .. path)
--     end
--     return realMake(fs, newPath, meta, target)
--   end
--
--   local aliases = {
--     "^github://([^/]+)/([^/@]+)/?@(.+)$", "https://github.com/%1/%2/archive/%3.zip",
--     "^github://([^/]+)/([^/]+)/?$", "https://github.com/%1/%2/archive/master.zip",
--     "^gist://([^/]+)/(.+)/?$", "https://gist.github.com/%1/%2.git",
--   }
--   core.urlAilases = aliases
--
--   local function makeHttp(target, url)
--     local res, body = http.request("GET", url)
--     assert(res.code == 200, body)
--     local filename
--     for i = 1, #res do
--       local key, value = unpack(res[i])
--       if key:lower() == "content-disposition" then
--         filename = value:match("filename=\"?([^;\"]+)")
--       end
--     end
--
--     local path = filename or (target or "app") .. ".zip"
--     fs.writeFile(path, body)
--     core.make(path, target)
--     fs.unlink(path)
--   end
--
--   local function makeGit(target, url)
--     local path = (url:match("([^/]+).git$") or target or "app") .. ".git-clone"
--     local stdout, stderr, code, signal = exec("git", "clone", "--depth=1", url, path)
--     if code == 0 and signal == 0 then
--       core.make(path, target)
--     else
--       error("Problem cloning: " .. stdout .. stderr)
--     end
--     exec("rm", "-rf", path)
--   end
--
--   local function makeLit(target, author, name, version)
--     local tag = author .. '/' .. name
--     local match, hash = db.match(author, name, version)
--     if not match then
--       if version then tag = tag .. "@" .. version end
--       error("No such lit package: " ..  tag)
--     end
--     tag = tag .. "@" .. match
--
--     db.fetch({hash})
--     local meta = pkg.queryDb(db, hash)
--     if not meta then
--       error("Not a valid package: " .. tag)
--     end
--     local fs = dbFs(db, hash)
--     fs.base = "lit://" .. tag
--     return realMake(fs, "", meta, target)
--   end
--
--   local handlers = {
--     "^(https?://[^#]+%.git)$", makeGit,
--     "^(https?://[^#]+)$", makeHttp,
--     "^(git://.*)$", makeGit,
--     "^lit://([^/]+)/([^@]+)@v?(.+)$", makeLit,
--     "^lit://([^/]+)/([^@]+)$", makeLit,
--     "^([^@/]+)/([^@]+)@v?(.+)$", makeLit,
--     "^([^@/]+)/([^@]+)$", makeLit,
--     "^([^ :/@]+%@.*)$", makeGit,
--   }
--   core.urlHandlers = handlers
--
--   function core.makeUrl(url, target)
--     local fullUrl = url
--     for i = 1, #aliases, 2 do
--       fullUrl = fullUrl:gsub(aliases[i], aliases[i + 1])
--     end
--     for i = 1, #handlers, 2 do
--       local match = {fullUrl:match(handlers[i])}
--       if #match > 0 then return handlers[i + 1](target, unpack(match)) end
--     end
--     error("Not a file or valid url: " .. fullUrl)
--   end
