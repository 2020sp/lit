List of all internal functions to be organized

Low Level Storage Commands
==========================

These are the filesystem abstraction needed by lit's local database.

storage.write(path, raw)     - Write mutable data by path
storage.put(path, raw)       - Write immutable data by path
storage.read(path) -> raw    - Read mutable data by path (nil if not found)
storage.delete(path)         - Delete an entry (removes empty parent directories)
storage.nodes(path) -> iter  - Iterate over node children of path
                               (empty iter if not found)
storage.leaves(path) -> iter - Iterate over node children of path
                               (empty iter if not found)

Mid Level Storage Commands
=========================

These commands work at a higher level and consume the low-level storage APIs.

db.load(hash) -> kind, value           - nil if not found
db.loadAs(kind, hash) -> value         - error if not found or wrong type
db.save(kind, value) -> hash           - encode and save to objects/$ha/$sh
db.hashes() -> iter                    - Iterate over all hashes

db.read(author, tag, version) -> hash  - Read from refs/tags/$author/$tag/v$version
db.write(author, tag, version, hash)   - Write to refs/tags/$suthor/$tag/v$version
db.authors() -> iter                   - Iterate over refs/tags/*
db.tags(author) -> iter                - Iterate nodes in refs/tags/$author/**
db.versions(author, tag) -> iter       - Iterate leaves in refs/tags/$author/$tag/*


db.readKey(author, fingerprint) -> key - Read from keys/$author/$fingerprint
db.writeKey(author, fingerprint, key)  - Write to keys/$author/$fingerprint
db.revokeKey(author, fingerprint)      - Delete keys/$author/$fingerprint
db.fingerprints(author) -> iter        - iter of fingerprints

db.getEtag(author) -> etag             - Read keys/$author/etag
db.setEtag(author, etag)               - Writes keys/$author/etag

db.owners(org) -> iter                 - Iterates lines of keys/$org/owners
db.isOwner(org, author) -> bool        - Check if a user is an org owner
db.addOwner(org, author)               - Add a new owner
db.removeOwner(org, author)            - Remove an owner

db.import(path) -> kind, hash          - Import a file or tree into database
db.export(hash, path) -> kind          - Export a hash to a path

Package Commands
================

These commands work with packages as units.  Consumes the db interface.

pkg.query(path) -> path, meta               - Query an on-disk path for package info.
pky.normalize(meta) -> author, tag, version - Extract and normalize pkg info

Core Functions
==============

These are the high-level actions.  This consumes a database instance

core.tag(path, name, email, key)
  -> author, tag, version, hash          - Import a package complete with signed tag.

REST API
========

This is a simple rest API for reading the remote database over HTTP.
It uses hypermedia in the JSON responses to make linking between requests simple.

GET / -> api json {
  blobs = "/blobs/{hash}"
  trees = "/trees/{hash}"
  packages = "/packages{/author}{/tag}{/version}"
}
GET /blobs/$HASH -> raw data
GET /trees/$HASH -> tree json {
 foo = { mode = 0644, hash = "...", url="/blobs/..." }
 bar = { mode = 0755, hash = "...", url="/trees/..." }
 ...
}
GET /packages -> authors json {
  creationix = "/packages/creationix"
  ...
}
GET /packages/$AUTHOR -> tags json {
  git = "/packages/creationix/git"
  ...
}
GET /packages/$AUTHOR/$TAG -> versions json {
  v0.1.2 = "/packages/creationix/git/v0.1.2"
  ...
}
GET /packages/$AUTHOR/$TAG/$VERSION -> tag json {
  hash = "..."
  object = "..."
  object_url = "/trees/..."
  type = "tree"
  tag = "v0.2.3"
  tagger = {
    name = "Tim Caswell",
    email = "tim@creationix.com",
    date = {
      seconds = 1423760148
      offset = -0600
    }
  }
  message = "..."
}

Server API Handlers
===================

handlers.read
handlers.match
handlers.wants
handlers.want
handlers.send
handlers.claim
handlers.share
handlers.unclaim

git.toDate (seconds) -> { seconds, offset}  - Convert from unix timestamp to git timestamp
git.fromDate ({seconds, offset}) -> seconds - Reverse the conversion

